grammar OracleSQL;

@header {
package com.example.personalchatbot.service.sql.antlr.oracle;
import org.antlr.v4.runtime.IntStream;
}

@lexer::members {
  private boolean atLineStartAfterWs() {
    int i = -1, la = _input.LA(i);
    while (la == ' ' || la == '\t') { i--; la = _input.LA(i); }
    return la == '\n' || la == '\r' || la == IntStream.EOF;
  }
}

/* ============================== Parser rules ============================== */

sql
    : (sqlStatement)+ EOF?
    ;

sqlStatement
    : stCreateTable
    | stCreateGtt
    | stCreateIndex
    | stCreateView
    | stCreateMaterializedView
    | stCreateSequence
    | stCreateSynonym
    | stCreateTrigger
    | stCreatePackageSpec
    | stCreatePackageBody
    | stCreateProcedure
    | stCreateFunction
    | stCreateType
    | stAnonymousBlock
    | stAlterSession
    | stComment
    | stOther
    ;

/* ====================== SQL STATEMENTS ====================== */
/* ---------- CREATE TABLE & GTT ---------- */
stCreateTable
  : CREATE TABLE qname LPAREN tableElement (COMMA tableElement)* RPAREN
    (partitionByRange)?
    terminatorSemi
  ;

stCreateGtt
  : CREATE GLOBAL TEMPORARY TABLE qname LPAREN tableElement (COMMA tableElement)* RPAREN onCommitClause?
        terminatorSemi
    ;

onCommitClause
  : ON COMMIT (PRESERVE ROWS | DELETE ROWS)
  ;

tableElement
  : columnDef
  | tableConstraint
  ;

columnDef
  : id dataType columnRest*
  ;

columnRest
  : DEFAULT expr                                        #colDefault
  | DEFAULT ON NULL expr                                #colDefaultOnNull
  | GENERATED ALWAYS AS LPAREN expr RPAREN VIRTUAL      #colGeneratedVirtual
  | GENERATED ALWAYS AS IDENTITY                        #colIdentityAlways
  | GENERATED BY DEFAULT AS IDENTITY                    #colIdentityByDefault
  | GENERATED BY DEFAULT ON NULL AS IDENTITY            #colIdentityByDefaultOnNull
  | constraintInline                                    #colConstraintInline
  ;

constraintInline
  : CONSTRAINT id? columnConstraint
  | columnConstraint
  ;

columnConstraint
  : ( NOT NULL
    | NULL
    | UNIQUE
    | PRIMARY KEY
    | CHECK LPAREN expr RPAREN
    | REFERENCES qname fkRefRest?
    ) constraintOptions?
  ;

fkRefRest
  : LPAREN id (COMMA id)* RPAREN onDeleteClause? deferrableClause?
  | onDeleteClause deferrableClause?
  | deferrableClause
  ;

constraintOption
  : usingIndex
  | enableClause
  | validateClause
  | relyClause
  | deferrableClause
  ;

constraintOptions
  : constraintOption+
  ;

onDeleteClause
  : ON DELETE (CASCADE | SET NULL)
  ;

deferrableClause
  : ( NOT )? DEFERRABLE ( INITIALLY ( DEFERRED | IMMEDIATE ) )?
  ;

enableClause   : ( ENABLE | DISABLE ) ;

validateClause : ( VALIDATE | NOVALIDATE ) ;

relyClause     : ( RELY | NORELY ) ;

usingIndex
  : USING INDEX ( qname )? ( LPAREN ( . )*? RPAREN )?
  ;

tableConstraint
  : (CONSTRAINT id?)? ( PRIMARY KEY LPAREN id (COMMA id)* RPAREN
  | UNIQUE LPAREN id (COMMA id)* RPAREN
  | CHECK LPAREN expr RPAREN
  | FOREIGN KEY LPAREN id (COMMA id)* RPAREN REFERENCES qname fkRefRest?) constraintOptions?
  ;

partitionByRange
  : PARTITION BY RANGE LPAREN id RPAREN LPAREN partitionSpec (COMMA partitionSpec)* RPAREN
  ;

partitionSpec
  : PARTITION id VALUES LESS THAN LPAREN ( DATE_ STRING | MAXVALUE ) RPAREN
  ;

/* ---------- CREATE INDEX ---------- */
stCreateIndex
  : CREATE (UNIQUE)? (BITMAP)? INDEX qname ON qname LPAREN indexExpr (COMMA indexExpr)* RPAREN
  terminatorSemi
  ;

indexExpr
  : expr
  ;

/* ---------- CREATE VIEW ---------- */
stCreateView
    :   CREATE ( OR REPLACE )? ( FORCE )? VIEW viewName=qname AS
        selectStatement
        terminatorSemi
    ;

/* ---------- CREATE MATERIALIZED VIEW ---------- */
stCreateMaterializedView
  : CREATE MATERIALIZED VIEW qname
    buildClause?
    refreshClause?
    AS selectStatement
        terminatorSemi
    ;

buildClause
  : BUILD (IMMEDIATE | DEFERRED)
  ;

refreshClause
  : REFRESH (FAST | COMPLETE | FORCE)?
    (ON (DEMAND | COMMIT))?
  ;

/* ---------- CREATE FUNCTION ---------- */
stCreateFunction
    :   CREATE ( OR REPLACE )? FUNCTION funName=id
        ( . )*?
        ( IS | AS )
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? FUNCTION funName=id
        ( . )*?
        ( IS | AS )
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

/* ---------- CREATE TYPE ---------- */
stCreateType
    :   CREATE ( OR REPLACE )? TYPE typeName=qname
        ( ( AS | IS ) ( . )*? )
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? TYPE typeName=qname
        ( ( AS | IS ) ( . )*? )
        terminatorSemi
    ;

/* ---------- SELECT ---------- */
selectStatement
    :   SELECT ( DISTINCT | ALL )? selectList fromClause selectTail?
    ;

selectTail
    :   ( WHERE | GROUP | HAVING | ORDER | UNION ) ( . )*?   // non-greedy: không cần chi tiết
    ;

selectList
    :   selectItem ( COMMA selectItem )*
    ;

selectItem
    :   sel=selectExpr ( (AS)? alias=id )?
    ;

selectExpr
    :   ( parens | ~(COMMA | FROM | SEMI) )+
    ;

fromClause
    :   FROM tableRef ( joinClause )*
    ;

tableRef
    :   qname ( id )?
    ;

joinClause
    :   ( LEFT | RIGHT | FULL | INNER )? ( OUTER )? JOIN tableRef joinCond
    ;

joinCond
    :   ON joinExpr
    ;

joinExpr
    :   ( parens | ~(JOIN | WHERE | GROUP | HAVING | ORDER | UNION | SEMI) )*
    ;

/* ---------- CREATE SEQUENCE / SYNONYM (đơn giản) ---------- */
stCreateSequence
    :   CREATE SEQUENCE seqName=id ( . )*? terminatorSemi
    ;

stCreateSynonym
  : CREATE ( OR REPLACE )? ( PUBLIC )? SYNONYM synName=id FOR qname terminatorSemi
  ;

/* ---------- CREATE TRIGGER / PACKAGE / PROCEDURE ---------- */
stCreateTrigger
    : CREATE ( OR REPLACE )? TRIGGER trgName=id
      ( . )*?
      BEGIN ( . )*? END ( id )?
      ( terminatorSemi )? slashTerm
    | CREATE ( OR REPLACE )? TRIGGER trgName=id
      ( . )*?
      BEGIN ( . )*? END ( id )?
      terminatorSemi
    ;

stCreatePackageSpec
    :   CREATE ( OR REPLACE )? PACKAGE pkgName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PACKAGE pkgName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

stCreatePackageBody
    :   CREATE ( OR REPLACE )? PACKAGE BODY pkgName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PACKAGE BODY pkgName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

stCreateProcedure
    :   CREATE ( OR REPLACE )? PROCEDURE procName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PROCEDURE procName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

/* ---------- COMMENT ---------- */
stComment
  : COMMENT ON ( TABLE qname
  | COLUMN qname DOT id
  | INDEX qname
  | VIEW qname
  | MATERIALIZED VIEW qname ) IS stringLiteral terminatorSemi
  ;

/* ---------- ALTER SESSION ---------- */
stAlterSession
    :   ALTER SESSION SET ( . )*? terminatorSemi
    ;

/* ---------- Anonymous PL/SQL block (BEGIN ... END;) + "/" ---------- */
stAnonymousBlock
    :   BEGIN ( . )*? END terminatorSemi? slashTerm
    ;

/* ---------- Other Statement ---------- */
stOther
    :   ( . )*? ( terminatorSemi | slashTerm )
    ;

/* ====================== EXPRESSIONS ====================== */
expr
    : logicalExpr
    ;

logicalExpr
    : comparisonExpr ( ( AND | OR ) comparisonExpr )*
    ;

comparisonExpr
  : concatExpr
    ( (EQUAL | NEQ1 | NEQ2 | LT | LE | GT | GE) concatExpr
    | IS (NOT)? NULL
    | IN LPAREN expr (COMMA expr)* RPAREN
    )?
  ;

concatExpr
    : addExpr ( CONCAT addExpr )*
    ;

addExpr
    : multExpr ( (PLUS | MINUS) multExpr )*
    ;

multExpr     : unaryExpr ( (STAR | DIV) unaryExpr )* ;

unaryExpr
    : (PLUS | MINUS | NOT)? primaryExpr
    ;

primaryExpr
    : literal
    | qname
    | functionCall
    | LPAREN expr RPAREN
    | bindVar
    ;

functionCall
    : qname LPAREN ( expr ( COMMA expr )* )? RPAREN
    ;

bindVar
    : COLON (IDENTIFIER | QUOTED_IDENTIFIER)
    ;

parens
    :   LPAREN ( parens | ~(LPAREN | RPAREN) )* RPAREN
    ;

/* ====================== LITERALS ====================== */
literal
    : STRING                         #strLiteral
    | DECIMAL                        #decLiteral
    | INT                            #intLiteral
    | DATE_ STRING                   #dateKeywordLiteral          // DATE 'YYYY-MM-DD'
    | TIMESTAMP STRING               #timestampKeywordLiteral     // TIMESTAMP 'YYYY-MM-DD HH24:MI:SS'
    | NULL                          #nullLiteral
    ;

/* ====================== DATATYPE ====================== */
dataType
  : NUMBER ( LPAREN INT ( COMMA INT )? RPAREN )?
  | VARCHAR2 LPAREN INT ( COMMA INT )? RPAREN ( BYTE | CHAR )?
  | CHAR LPAREN INT RPAREN ( BYTE | CHAR )?
  | DATE_
  | TIMESTAMP ( LPAREN INT RPAREN )? ( WITH ( LOCAL )? TIME ZONE )?
  | CLOB | NCLOB | BLOB
  | RAW ( LPAREN INT RPAREN )?
  | NCHAR LPAREN INT RPAREN
  | NVARCHAR2 LPAREN INT RPAREN
  ;

/* ==================== Common helpers ==================== */
terminatorSemi : SEMI ;
slashTerm    : SLASH_TERM ;
qname          : id ( DOT id )* ;
id             : IDENTIFIER | QUOTED_IDENTIFIER ;
stringLiteral  : STRING ;

/* ============================== Lexer rules ============================== */

// ======= Operators & symbols =======
CONCAT      : '||' ;
NEQ2        : '<>' ;
NEQ1        : '!=' ;
LE          : '<=' ;
GE          : '>=' ;
EQUAL       : '=' ;
LT          : '<' ;
GT          : '>' ;
PLUS        : '+' ;
MINUS       : '-' ;
STAR        : '*' ;
PERCENT     : '%' ;
COLON       : ':' ;
PIPE        : '|' ;
LPAREN      : '(' ;
RPAREN      : ')' ;
COMMA       : ',' ;
DOT         : '.' ;
SEMI        : ';' ;
SLASH_TERM : {atLineStartAfterWs()}? '/' [ \t]* ( '\r'? '\n' | EOF ) ;
DIV        : '/' ;

// ======= Numbers =======
INT         : [0-9]+ ;
DECIMAL     : [0-9]+ '.' [0-9]+ ;

/* Keywords (uppercase) */
CREATE      : 'CREATE' ;
OR          : 'OR' ;
REPLACE     : 'REPLACE' ;
FORCE       : 'FORCE' ;
TABLE       : 'TABLE' ;
GLOBAL      : 'GLOBAL' ;
TEMPORARY   : 'TEMPORARY' ;
INDEX       : 'INDEX' ;
BITMAP      : 'BITMAP' ;
VIEW        : 'VIEW' ;
MATERIALIZED : 'MATERIALIZED' ;
SEQUENCE    : 'SEQUENCE' ;
SYNONYM     : 'SYNONYM' ;
TRIGGER     : 'TRIGGER' ;
PACKAGE     : 'PACKAGE' ;
BODY        : 'BODY' ;
PROCEDURE   : 'PROCEDURE' ;
AS          : 'AS' ;
IS          : 'IS' ;
BEGIN       : 'BEGIN' ;
END         : 'END' ;
COMMENT     : 'COMMENT' ;
ON          : 'ON' ;
COLUMN      : 'COLUMN' ;
ALTER       : 'ALTER' ;
SESSION     : 'SESSION' ;
SET         : 'SET' ;
SELECT      : 'SELECT' ;
DISTINCT    : 'DISTINCT' ;
ALL         : 'ALL' ;
FROM        : 'FROM' ;
WHERE       : 'WHERE' ;
GROUP       : 'GROUP' ;
BY          : 'BY' ;
HAVING      : 'HAVING' ;
ORDER       : 'ORDER' ;
JOIN        : 'JOIN' ;
LEFT        : 'LEFT' ;
RIGHT       : 'RIGHT' ;
FULL        : 'FULL' ;
INNER       : 'INNER' ;
OUTER       : 'OUTER' ;
UNION       : 'UNION' ;
BUILD       : 'BUILD' ;
IMMEDIATE   : 'IMMEDIATE' ;
REFRESH     : 'REFRESH' ;
COMPLETE    : 'COMPLETE' ;
DEMAND      : 'DEMAND' ;
FUNCTION    : 'FUNCTION' ;
RETURN      : 'RETURN' ;
FOR         : 'FOR' ;
ALWAYS      : 'ALWAYS' ;
DEFAULT     : 'DEFAULT' ;
NULL        : 'NULL' ;
VIRTUAL     : 'VIRTUAL' ;
GENERATED   : 'GENERATED' ;
IDENTITY    : 'IDENTITY';
DEFERRABLE  : 'DEFERRABLE';
INITIALLY   : 'INITIALLY';
DEFERRED    : 'DEFERRED';
NOT         : 'NOT' ;
AND         : 'AND' ;
PRIMARY     : 'PRIMARY' ;
KEY         : 'KEY' ;
UNIQUE      : 'UNIQUE' ;
CHECK       : 'CHECK' ;
FOREIGN     : 'FOREIGN' ;
REFERENCES  : 'REFERENCES' ;
CONSTRAINT  : 'CONSTRAINT' ;
PARTITION   : 'PARTITION' ;
RANGE       : 'RANGE' ;
VALUES      : 'VALUES' ;
LESS        : 'LESS' ;
THAN        : 'THAN' ;
MAXVALUE    : 'MAXVALUE' ;
DATE_       : 'DATE' ;
TIMESTAMP   : 'TIMESTAMP' ;
TIME        : 'TIME' ;
ZONE        : 'ZONE' ;
WITH        : 'WITH' ;
LOCAL       : 'LOCAL' ;
VARCHAR2    : 'VARCHAR2' ;
CHAR        : 'CHAR' ;
NUMBER      : 'NUMBER' ;
COMMIT      : 'COMMIT' ;
PRESERVE    : 'PRESERVE' ;
ROWS        : 'ROWS' ;
DELETE      : 'DELETE';
FAST        : 'FAST' ;
IN          : 'IN' ;
CASCADE     : 'CASCADE' ;
PUBLIC      : 'PUBLIC';
BYTE        : 'BYTE';
CLOB        : 'CLOB';
NCLOB       : 'NCLOB';
BLOB        : 'BLOB';
RAW         : 'RAW';
NCHAR       : 'NCHAR';
NVARCHAR2   : 'NVARCHAR2';
ENABLE      : 'ENABLE';
DISABLE     : 'DISABLE';
VALIDATE    : 'VALIDATE';
NOVALIDATE  : 'NOVALIDATE';
RELY        : 'RELY';
NORELY      : 'NORELY';
USING       : 'USING';
TYPE        : 'TYPE';


/* Identifier & literal */
QUOTED_IDENTIFIER
    :   '"' ( '""' | ~["\r\n] )* '"'
    ;

IDENTIFIER
    :   [A-Za-z_] [A-Za-z_0-9$#]*
    ;

/* Chuỗi ký tự (string literal) */
STRING
    :   '\'' ( '\'\'' | ~['\r\n] )* '\''
    ;

/* Bỏ qua khoảng trắng & comment */
WS              : [ \t\r\n]+ -> skip ;
LINE_COMMENT    : '--' ~[\r\n]* -> skip ;
BLOCK_COMMENT   : '/*' .*? '*/' -> skip ;