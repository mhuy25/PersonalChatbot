grammar OracleSQL;

@header {
package com.example.personalchatbot.service.sql.antlr.oracle;
}

/* ============================== Parser rules ============================== */

sql
    : (sqlStatement)+ EOF?
    ;

sqlStatement
    : stCreateTable
    | stCreateGtt
    | stCreateIndex
    | stCreateView
    | stCreateMaterializedView
    | stCreateSequence
    | stCreateSynonym
    | stCreateTrigger
    | stCreatePackageSpec
    | stCreatePackageBody
    | stCreateProcedure
    | stAnonymousBlock
    | stAlterSession
    | stComment
    | stOther
    ;

/* ---------- CREATE TABLE & GTT: bắt danh sách cột ---------- */

stCreateTable
  : CREATE TABLE qname LPAREN tableElement (COMMA tableElement)* RPAREN
    (partitionByRange)?
    terminatorSemi
  ;

stCreateGtt
  : CREATE GLOBAL TEMPORARY TABLE qname LPAREN tableElement (COMMA tableElement)* RPAREN onCommitClause?
        terminatorSemi
    ;

onCommitClause
  : ON COMMIT (PRESERVE ROWS | DELETE ROWS)
  ;

/** Một phần tử trong () của CREATE TABLE */
tableElement
  : columnDef
  | tableConstraint
  ;

columnDef
  : id dataType columnRest*
  ;

columnRest
  : DEFAULT expr                                        #colDefault
  | DEFAULT ON NULL expr                                #colDefaultOnNull
  | GENERATED ALWAYS AS LPAREN expr RPAREN VIRTUAL      #colGeneratedVirtual
  | GENERATED ALWAYS AS IDENTITY                        #colIdentityAlways
  | GENERATED BY DEFAULT AS IDENTITY                    #colIdentityByDefault
  | GENERATED BY DEFAULT ON NULL AS IDENTITY            #colIdentityByDefaultOnNull
  | constraintInline                                    #colConstraintInline
  ;

constraintInline
  : CONSTRAINT id? columnConstraint
  | columnConstraint
  ;

columnConstraint
  : NOT NULL
  | NULL
  | UNIQUE
  | PRIMARY KEY
  | CHECK LPAREN expr RPAREN
  | REFERENCES qname fkRefRest?
  ;


fkRefRest
  : LPAREN id (COMMA id)* RPAREN onDeleteClause? deferrableClause?
  | onDeleteClause? deferrableClause
  ;

onDeleteClause
  : ON DELETE (CASCADE | SET NULL)
  ;

deferrableClause
  : DEFERRABLE (INITIALLY (DEFERRED | IMMEDIATE))?
  ;

tableConstraint
  : CONSTRAINT id? (
        PRIMARY KEY LPAREN id (COMMA id)* RPAREN
      | UNIQUE LPAREN id (COMMA id)* RPAREN
      | CHECK LPAREN expr RPAREN
      | FOREIGN KEY LPAREN id (COMMA id)* RPAREN REFERENCES qname fkRefRest?
    )
  ;

partitionByRange
  : PARTITION BY RANGE LPAREN id RPAREN LPAREN partitionSpec (COMMA partitionSpec)* RPAREN
  ;

partitionSpec
  : PARTITION id VALUES LESS THAN LPAREN (DATE_ literal | MAXVALUE) RPAREN
  ;

/* ====================== LITERALS ====================== */
literal
    : STRING                         #strLiteral
    | DECIMAL                        #decLiteral
    | INT                            #intLiteral
    | DATE_ STRING                   #dateKeywordLiteral          // DATE 'YYYY-MM-DD'
    | TIMESTAMP STRING               #timestampKeywordLiteral     // TIMESTAMP 'YYYY-MM-DD HH24:MI:SS' (để nguyên chuỗi)
    | NULL                          #nullLiteral
    ;

/* ====================== DATATYPE ====================== */
/* Đủ dùng cho script: NUMBER, VARCHAR2, CHAR, DATE, TIMESTAMP */
dataType
    : NUMBER ( LPAREN INT ( COMMA INT )? RPAREN )?                                 #dtNumber
    | VARCHAR2 LPAREN INT ( COMMA INT )? RPAREN                                    #dtVarchar2
    | CHAR LPAREN INT RPAREN                                                       #dtChar
    | DATE_                                                                        #dtDate
    | TIMESTAMP ( LPAREN INT RPAREN )? ( WITH ( LOCAL )? TIME ZONE )?              #dtTimestamp
    ;

/* ====================== EXPRESSIONS ====================== */
/* Tiền lệ ưu tiên tối thiểu để chịu được DEFAULT/CHECK/VIRTUAL/SELECT list */
expr
    : logicalExpr
    ;

logicalExpr
    : comparisonExpr ( ( AND | OR ) comparisonExpr )*
    ;

comparisonExpr
  : concatExpr
    ( (EQUAL | NEQ1 | NEQ2 | LT | LE | GT | GE) concatExpr
    | IS (NOT)? NULL
    | IN LPAREN expr (COMMA expr)* RPAREN
    )?
  ;

concatExpr
    : addExpr ( CONCAT addExpr )*
    ;

addExpr
    : multExpr ( (PLUS | MINUS) multExpr )*
    ;

multExpr
    : unaryExpr ( (STAR | SLASH) unaryExpr )*
    ;

unaryExpr
    : (PLUS | MINUS | NOT)? primaryExpr
    ;

primaryExpr
    : literal
    | qname                               // cột/tên bảng/func không tham số cũng chịu được
    | functionCall
    | LPAREN expr RPAREN
    | bindVar                             // :NEW, :OLD, :x
    ;

functionCall
    : qname LPAREN ( expr ( COMMA expr )* )? RPAREN
    ;

bindVar
    : COLON (IDENTIFIER | QUOTED_IDENTIFIER)
    ;

/** Ngoặc lồng nhau dùng đệ quy */
parens
    :   LPAREN ( parens | ~(LPAREN | RPAREN) )* RPAREN
    ;

/* ---------- CREATE INDEX ---------- */
stCreateIndex
  : CREATE (UNIQUE)? (BITMAP)? INDEX qname ON qname LPAREN indexExpr (COMMA indexExpr)* RPAREN
  terminatorSemi
  ;

indexExpr
  : expr
  ;

/* ---------- CREATE VIEW: lấy selectList & FROM/JOIN ---------- */
stCreateView
    :   CREATE ( OR REPLACE )? ( FORCE )? VIEW viewName=qname AS
        selectStatement
        terminatorSemi
    ;

/* ---------- CREATE MATERIALIZED VIEW: lấy selectList & FROM/JOIN ---------- */
stCreateMaterializedView
  : CREATE MATERIALIZED VIEW qname
    buildClause?
    refreshClause?
    AS selectStatement
        terminatorSemi
    ;

buildClause
  : BUILD (IMMEDIATE | DEFERRED)
  ;

refreshClause
  : REFRESH (FAST | COMPLETE | FORCE)?
    (ON (DEMAND | COMMIT))?
  ;

/* ---------- SELECT (tối giản, đủ lấy cột & bảng nguồn) ---------- */
selectStatement
    :   SELECT ( DISTINCT | ALL )? selectList fromClause selectTail?
    ;

selectTail
    :   ( WHERE | GROUP | HAVING | ORDER | UNION ) ( . )*?   // non-greedy: không cần chi tiết
    ;

selectList
    :   selectItem ( COMMA selectItem )*
    ;

selectItem
    :   sel=selectExpr ( (AS)? alias=id )?
    ;

selectExpr
    :   ( parens | ~(COMMA | FROM | SEMI | SLASH) )+
    ;

fromClause
    :   FROM tableRef ( joinClause )*
    ;

tableRef
    :   qname ( id )?
    ;

joinClause
    :   ( LEFT | RIGHT | FULL | INNER )? ( OUTER )? JOIN tableRef joinCond
    ;

joinCond
    :   ON joinExpr
    ;

joinExpr
    :   ( parens | ~(JOIN | WHERE | GROUP | HAVING | ORDER | UNION | SEMI | SLASH) )*
    ;

/* ---------- CREATE SEQUENCE / SYNONYM (đơn giản) ---------- */
stCreateSequence
    :   CREATE SEQUENCE seqName=id ( . )*? terminatorSemi
    ;

stCreateSynonym
    :   CREATE ( OR REPLACE )? SYNONYM synName=id FOR qname terminatorSemi
    ;

/* ---------- CREATE TRIGGER / PACKAGE / PROCEDURE ---------- */
stCreateTrigger
    : CREATE ( OR REPLACE )? TRIGGER trgName=id
      ( . )*?
      BEGIN ( . )*? END ( id )?
      ( terminatorSemi )? slashTerm
    | CREATE ( OR REPLACE )? TRIGGER trgName=id
      ( . )*?
      BEGIN ( . )*? END ( id )?
      terminatorSemi
    ;

stCreatePackageSpec
    :   CREATE ( OR REPLACE )? PACKAGE pkgName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PACKAGE pkgName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

stCreatePackageBody
    :   CREATE ( OR REPLACE )? PACKAGE BODY pkgName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PACKAGE BODY pkgName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

stCreateProcedure
    :   CREATE ( OR REPLACE )? PROCEDURE procName=id
        ( . )*?
        END ( id )?
        ( terminatorSemi )? slashTerm
    |   CREATE ( OR REPLACE )? PROCEDURE procName=id
        ( . )*?
        END ( id )?
        terminatorSemi
    ;

/* ---------- COMMENT ---------- */
stComment
    :   COMMENT ON ( TABLE qname | COLUMN qname DOT id ) IS stringLiteral terminatorSemi
    ;

/* ---------- ALTER SESSION ---------- */
stAlterSession
    :   ALTER SESSION SET ( . )*? terminatorSemi
    ;

/* ---------- Anonymous PL/SQL block (BEGIN ... END;) + "/" ---------- */
stAnonymousBlock
    :   BEGIN ( . )*? END terminatorSemi? slashTerm
    ;

/* ---------- Fallback cho statement khác (để vẫn split được) ---------- */
stOther
    :   ( . )*? ( terminatorSemi | slashTerm )
    ;

/* ---------- Helpers ---------- */
terminatorSemi : SEMI ;
slashTerm      : SLASH ;
qname          : id ( DOT id )* ;
id             : IDENTIFIER | QUOTED_IDENTIFIER ;
stringLiteral  : STRING ;

/* ============================== Lexer rules ============================== */

// ======= Operators & symbols (add these) =======
CONCAT      : '||' ;
NEQ2        : '<>' ;
NEQ1        : '!=' ;
LE          : '<=' ;
GE          : '>=' ;

EQUAL       : '=' ;
LT          : '<' ;
GT          : '>' ;
PLUS        : '+' ;
MINUS       : '-' ;
STAR        : '*' ;
PERCENT     : '%' ;
COLON       : ':' ;
PIPE        : '|' ;

// ======= Numbers (đủ dùng cho DDL) =======
INT         : [0-9]+ ;
DECIMAL     : [0-9]+ '.' [0-9]+ ;

/* Ký hiệu */
LPAREN  : '(' ;
RPAREN  : ')' ;
COMMA   : ',' ;
DOT     : '.' ;
SEMI    : ';' ;
SLASH   : '/' ;

/* Keywords (uppercase) */
CREATE  : 'CREATE' ;
OR      : 'OR' ;
REPLACE : 'REPLACE' ;
FORCE   : 'FORCE' ;
TABLE   : 'TABLE' ;
GLOBAL  : 'GLOBAL' ;
TEMPORARY : 'TEMPORARY' ;
INDEX   : 'INDEX' ;
BITMAP  : 'BITMAP' ;
VIEW    : 'VIEW' ;
MATERIALIZED : 'MATERIALIZED' ;
SEQUENCE: 'SEQUENCE' ;
SYNONYM : 'SYNONYM' ;
TRIGGER : 'TRIGGER' ;
PACKAGE : 'PACKAGE' ;
BODY    : 'BODY' ;
PROCEDURE : 'PROCEDURE' ;
AS      : 'AS' ;
IS      : 'IS' ;
BEGIN   : 'BEGIN' ;
END     : 'END' ;
COMMENT : 'COMMENT' ;
ON      : 'ON' ;
COLUMN  : 'COLUMN' ;
ALTER   : 'ALTER' ;
SESSION : 'SESSION' ;
SET     : 'SET' ;
SELECT  : 'SELECT' ;
DISTINCT: 'DISTINCT' ;
ALL     : 'ALL' ;
FROM    : 'FROM' ;
WHERE   : 'WHERE' ;
GROUP   : 'GROUP' ;
BY      : 'BY' ;
HAVING  : 'HAVING' ;
ORDER   : 'ORDER' ;
JOIN    : 'JOIN' ;
LEFT    : 'LEFT' ;
RIGHT   : 'RIGHT' ;
FULL    : 'FULL' ;
INNER   : 'INNER' ;
OUTER   : 'OUTER' ;
UNION   : 'UNION' ;
BUILD   : 'BUILD' ;
IMMEDIATE : 'IMMEDIATE' ;
REFRESH : 'REFRESH' ;
COMPLETE: 'COMPLETE' ;
DEMAND  : 'DEMAND' ;
FUNCTION: 'FUNCTION' ;
RETURN  : 'RETURN' ;
FOR     : 'FOR' ;
ALWAYS  : 'ALWAYS' ;
DEFAULT : 'DEFAULT' ;
NULL   : 'NULL' ;
VIRTUAL : 'VIRTUAL' ;
GENERATED : 'GENERATED' ;
IDENTITY : 'IDENTITY';
DEFERRABLE : 'DEFERRABLE';
INITIALLY : 'INITIALLY';
DEFERRED : 'DEFERRED';
NOT         : 'NOT' ;
AND         : 'AND' ;
PRIMARY     : 'PRIMARY' ;
KEY         : 'KEY' ;
UNIQUE      : 'UNIQUE' ;
CHECK       : 'CHECK' ;
FOREIGN     : 'FOREIGN' ;
REFERENCES  : 'REFERENCES' ;
CONSTRAINT  : 'CONSTRAINT' ;
PARTITION   : 'PARTITION' ;
RANGE       : 'RANGE' ;
VALUES      : 'VALUES' ;
LESS        : 'LESS' ;
THAN        : 'THAN' ;
MAXVALUE    : 'MAXVALUE' ;
DATE_       : 'DATE' ;
TIMESTAMP   : 'TIMESTAMP' ;
TIME        : 'TIME' ;
ZONE        : 'ZONE' ;
WITH        : 'WITH' ;
LOCAL       : 'LOCAL' ;
VARCHAR2    : 'VARCHAR2' ;
CHAR        : 'CHAR' ;
NUMBER      : 'NUMBER' ;
COMMIT      : 'COMMIT' ;
PRESERVE    : 'PRESERVE' ;
ROWS    : 'ROWS' ;
DELETE  : 'DELETE';
FAST    : 'FAST' ;
IN      : 'IN' ;
CASCADE : 'CASCADE' ;

/* Identifier & literal */
QUOTED_IDENTIFIER
    :   '"' ( '""' | ~["\r\n] )* '"'
    ;

IDENTIFIER
    :   [A-Za-z_] [A-Za-z_0-9$#]*
    ;

/* Chuỗi ký tự (string literal) */
STRING
    :   '\'' ( '\'\'' | ~['\r\n] )* '\''
    ;

/* Bỏ qua khoảng trắng & comment */
WS              : [ \t\r\n]+ -> skip ;
LINE_COMMENT    : '--' ~[\r\n]* -> skip ;
BLOCK_COMMENT   : '/*' .*? '*/' -> skip ;